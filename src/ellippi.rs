/*
 * Ellip is licensed under The 3-Clause BSD, see LICENSE.
 * Copyright 2025 Sira Pornsiriprasert <code@psira.me>
 * This code is translated from Boost Math.
 */

// Original header from Boost Math
//  Copyright (c) 2006 Xiaogang Zhang
//  Copyright (c) 2006 John Maddock
//  Use, modification and distribution are subject to the
//  Boost Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//  History:
//  XZ wrote the original of this file as part of the Google
//  Summer of Code 2006.  JM modified it to fit into the
//  Boost.Math conceptual framework better, and to correctly
//  handle the various corner cases.
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

use std::f64::consts::PI;

use crate::{ellipk, elliprf, elliprj};

pub fn ellippi(n: f64, m: f64) -> Result<f64, &'static str> {
    // Compute vc = 1-v without cancellation errors
    let vc = 1.0 - n;
    _ellippi(n, m, vc)
}

#[inline]
fn _ellippi(n: f64, m: f64, vc: f64) -> Result<f64, &'static str> {
    if m >= 1.0 {
        return Err("ellippi: m must be less than 1.");
    }
    if vc <= 0.0 {
        return Err("ellippi: n must be less than 1.");
    }

    if n == 0.0 {
        if m == 0.0 {
            return Ok(PI / 2.0);
        }
        return ellipk(m);
    }

    if n < 0.0 {
        // Apply A&S 17.7.17
        let nn = (m - n) / (1.0 - n);
        let nm1 = (1.0 - m) / (1.0 - n);

        let mut result = _ellippi(nn, m, nm1)?;
        // Split calculations to avoid overflow/underflow
        result *= -n / (1.0 - n);
        result *= (1.0 - m) / (m - n);
        result += ellipk(m)? * m / (m - n);
        return Ok(result);
    }

    let x = 0.0;
    let y = 1.0 - m;
    let z = 1.0;
    let p = vc;

    let f = elliprf(x, y, z)?;
    let rj = elliprj(x, y, z, p)?;
    Ok(f + n * rj / 3.0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::compare_test_data;

    fn ellippi_k(inp: &[f64]) -> f64 {
        ellippi(inp[0], inp[1] * inp[1]).unwrap()
    }

    #[test]
    fn test_ellippi() {
        compare_test_data!("./tests/data/boost/ellint_pi2_data_f64.txt", ellippi_k, 1.6e-14);
    }
}
